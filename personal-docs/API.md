You are describing the **"Holy Grail" of Distributed Systems**: 
1.  **Zero-Coupling:** The client defines *nothing*.
2.  **Type Safety:** The compiler checks *everything*.
3.  **Location Transparency:** Use code from "Dad's Cell" as if it were a local library.

To achieve this in a compiled language like Rust without manual dependency management, we use **"Genome Reflection"**. 

1.  **The Server** embeds its own source code (its "Genome") into its binary.
2.  **The Tooling** (`membrane sync`) fetches this definition from the live network and caches it.
3.  **The Client** uses a macro (`cell::import!`) to inject that definition into the code at compile time.

Here is the exact implementation to achieve your "1 Line of Code" requirement.

---

### 1. The Server (Dad's Cell)

Dad writes this **once**. He defines the data structure and the logic in the same place.

**Path: `dad-workspace/src/main.rs`**

```rust
use cell_sdk::prelude::*;

// 1. Define the Signal (The Data)
// The macro captures this struct's definition and makes it download-able.
#[cell::signal]
pub struct DadJokeReq {
    pub topic: String,
    pub annoyance_level: u8,
}

#[cell::signal]
pub struct DadJokeResp {
    pub pun: String,
}

// 2. Define the Logic (The Nucleus)
#[cell::nucleus]
async fn dad_bot(req: DadJokeReq) -> Result<DadJokeResp> {
    Ok(DadJokeResp {
        pun: format!("Hi {}, I'm Dad!", req.topic)
    })
}

// 3. Auto-start
fn main() { dad_bot::main().unwrap(); }
```

---

### 2. The Client (Your Cell)

You write this. You do **not** copy Dad's structs. You do **not** add a git dependency. You just **import the live cell**.

**Path: `my-workspace/src/main.rs`**

```rust
use cell_sdk::prelude::*;

// 1 LINE OF CODE.
// This macro looks for 'dad_bot' in your local cache.
// If missing, it tells you to run 'membrane sync dad_bot'.
// It expands into the ACTUAL Rust structs defined by Dad.
cell::import!("dad_bot");

#[tokio::main]
async fn main() -> Result<()> {
    // COMPILE TIME SAFETY!
    // The compiler knows 'DadJokeReq' exists because the macro injected it.
    // If you typo 'topic', the compiler yells at you.
    let req = DadJokeReq {
        topic: "Hungry".to_string(),
        annoyance_level: 10
    };

    // The 'send()' method is auto-generated by the import.
    // It knows exactly where 'dad_bot' lives in the mesh.
    let response = req.send().await?;

    println!("Dad says: {}", response.pun);
    Ok(())
}
```

---

### 3. The Magic (How it works)

You need to implement the tooling that bridges the gap.

#### A. The `cell-macros` (Capturing the Source)

We update the `#[cell::signal]` macro to store the struct's source code as a string constant inside the generated code.

**Path: `cell-macros/src/lib.rs`**

```rust
#[proc_macro_attribute]
pub fn signal(_args: TokenStream, input: TokenStream) -> TokenStream {
    let item_struct = parse_macro_input!(input as ItemStruct);
    let struct_name = &item_struct.ident;
    
    // 1. Capture the Source Code of the Struct
    let struct_source = quote!(#item_struct).to_string();

    quote! {
        // The actual struct for the code to use
        #[derive(::cell_sdk::prelude::CellData)]
        #item_struct

        // Embed the source code so the Daemon can serve it to clients
        impl #struct_name {
            pub const GENOME_SOURCE: &'static str = #struct_source;
        }
    }.into()
}

#[proc_macro]
pub fn import(input: TokenStream) -> TokenStream {
    let cell_name = parse_macro_input!(input as syn::LitStr).value();
    
    // 1. Look for the cached genome file
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let cache_path = std::path::Path::new(&manifest_dir)
        .join(".cell/data")
        .join(format!("{}.rs", cell_name));

    // 2. If missing, fail compilation with a helpful message
    if !cache_path.exists() {
        return quote! {
            compile_error!(concat!(
                "Cell '", #cell_name, "' not found locally.\n",
                "Run: 'membrane sync ", #cell_name, "' to fetch its definition from the network."
            ));
        }.into();
    }

    // 3. If present, inject the code directly into this scope
    let code = std::fs::read_to_string(cache_path).expect("Failed to read cache");
    let parsed: proc_macro2::TokenStream = code.parse().expect("Cached genome is invalid Rust");

    quote! {
        #parsed
    }.into()
}
```

#### B. The CLI (`membrane sync`)

This is the command you run *once* when you want to use a new cell. It connects to Dad's running cell, asks for its source code, and saves it.

**Path: `cell-cli/src/main.rs`** (Add this command)

```rust
async fn sync(cell_name: &str) -> Result<()> {
    println!("ðŸ” Searching mesh for '{}'...", cell_name);
    
    // 1. Discovery (Pheromones/Golgi)
    let addr = resolve_cell_address(cell_name).await?;
    
    // 2. Connect via RPC
    let mut conn = connect(addr).await?;
    
    // 3. Request the special "__GENOME__" meta-signal
    let source_code = conn.request_genome().await?;
    
    // 4. Save to local cache
    let path = Path::new(".cell/data").join(format!("{}.rs", cell_name));
    fs::create_dir_all(path.parent().unwrap())?;
    fs::write(&path, source_code)?;
    
    println!("Genome acquired. You can now use '{}' in your code.", cell_name);
    Ok(())
}
```

### The Workflow Result

1.  **Dad** writes code and runs it.
2.  **You** write `cell::import!("dad_bot")`.
3.  **You** run `cargo build`.
    *   *Compiler Error: "Run membrane sync dad_bot"*
4.  **You** run `membrane sync dad_bot`.
    *   *System finds Dad, downloads struct definitions, saves to `.cell/data/dad_bot.rs`.*
5.  **You** run `cargo build`.
    *   *Success.* The compiler now sees Dad's structs in your code.
6.  **You** change `annoyance_level` to a String.
    *   *Compiler Error: expected u8, found String.* **(Safety Achieved)**

This fulfills your vision: **Defined Once (Dad), Used Anywhere (You), 1 Line of Code (Import), Compile Time Safety (Native Rust Types).**


To make this system **more powerful**, we need to move beyond simple Request/Response. We need to tackle the hardest problems in distributed systems: **Versioning**, **Offline Development**, **State Management**, and **Flow Control**.

Here are 4 specific upgrades to make Cell the ultimate distributed substrate.

---

### 1. The Immune System (Automatic Contract Hashing)
**Problem:** Dad changes `DadJokeReq` (renames a field) but forgets to tell you. You run your code. It compiles (against the old cache) but crashes at runtime because the serialization format changed.

**Solution:** The `#[cell::signal]` macro shouldn't just save source code; it should calculate a cryptographic **Hash of the Structure**.

**How it works:**
1.  **Dad's Compiler** calculates `SHA256("struct DadJokeReq { topic: String ... }")`.
2.  This hash is embedded into the Network Handshake.
3.  **Your Client** calculates the hash of the definition it *thinks* it has.
4.  If they mismatch, the connection is **rejected instantly** with a "Mutation Detected" error, prompting you to re-sync.

**The Code (Dad's side):**
The macro auto-generates this:
```rust
impl DadJokeReq {
    // Generated automatically by analyzing the AST
    pub const GENOME_HASH: u64 = 0x8F32_A1B2_C3D4; 
}
```

**The Code (Your side):**
The `import!` macro generates a check:
```rust
// Auto-generated inside import!
if server_hash != DadJokeReq::GENOME_HASH {
    panic!("Viral Mutation Detected! Dad has updated his cell. Run 'membrane sync' to update.");
}
```

---

### 2. Mirror Neurons (Simulation & Offline Mode)
**Problem:** You are on a plane, or Dad shuts down his computer. You can't code because your cell depends on his live cell.

**Solution:** **"VCR" Recording.**
Because every input/output is a strict struct, we can record them easily.

**The Upgrade:**
You can import a cell in **Simulation Mode**.

```rust
// If Dad is online, it calls him and saves the result to .cell/tapes/dad_bot.json
// If Dad is offline, it looks up the request in the JSON and returns the saved answer.
cell::import!("dad_bot", mode = "cache_fallback");

#[tokio::main]
async fn main() -> Result<()> {
    let req = DadJokeReq { topic: "Pizza".to_string() };
    
    // Works even if you have no internet!
    let resp = req.send().await?; 
    println!("{}", resp.pun);
    Ok(())
}
```

This makes your development cycle **invincible**. You can run full integration tests without spinning up the entire cluster.

---

### 3. Cellular Memory (Managed State)
**Problem:** Currently, `#[nucleus]` functions are pure logic (Input -> Output). Real apps need databases, counters, and file storage.

**Solution:** Introduce **`#[cell::state]`**.
Instead of manually opening DB connections inside your function (which is slow and error-prone), the Cell Runtime injects it for you.

**Dad's Code:**
```rust
use cell_sdk::prelude::*;

#[derive(CellData, Default)] // Define what the memory looks like
pub struct DadMemory {
    pub jokes_told: u64,
    pub bad_puns_db: std::collections::HashMap<String, String>,
}

#[cell::signal]
pub struct JokeReq { topic: String }

// Inject 'state' as a second argument. 
// The Runtime handles locking, persistence, and loading from disk.
#[cell::nucleus]
async fn dad_bot(req: JokeReq, state: &mut DadMemory) -> Result<String> {
    state.jokes_told += 1; // It persists automatically!
    
    let pun = state.bad_puns_db.get(&req.topic)
        .cloned()
        .unwrap_or("Hi hungry, I'm dad".to_string());
        
    Ok(pun)
}
```

**Why is this powerful?**
*   **Zero-Config Persistence:** If the cell crashes and restarts, `state` is reloaded from disk/Snapshot automatically.
*   **Concurrency Safety:** The runtime ensures no two requests corrupt the memory.

---

### 4. Mitosis (Auto-Scaling)
**Problem:** Dad's joke service goes viral. One process isn't enough.

**Solution:** Because your code is **Stateless Logic** + **Managed State**, the Daemon can clone the process automatically.

**The Configuration:**
You don't change your code. You change the runtime config.

```toml
# dad-workspace/Cell.toml
[nucleus]
name = "dad_bot"
replicas = "auto" # The Daemon spawns more cells if CPU > 80%
max_replicas = 50
```

**The Router (Golgi) Logic:**
1.  You send `DadJokeReq`.
2.  The Router sees 50 instances of `dad_bot`.
3.  It hashes your request ID (or round-robins) to pick one.
4.  **Power Move:** If `DadMemory` is used, the system can automatically shard the requests based on the input data (e.g., Topic A-M goes to Cell 1, N-Z goes to Cell 2).

---

### The Final "God Mode" Syntax

Combining all these improvements, here is what the system looks like now.

**Your Code (The Ultimate Consumer):**

```rust
use cell_sdk::prelude::*;

// 1. Import Dad's logic. Use cache if he's offline.
cell::import!("dad_bot", mode = "cache_fallback");

// 2. Import a Database Cell (Postgres/Redis wrapper)
cell::import!("mem_store");

#[tokio::main]
async fn main() -> Result<()> {
    // This looks like local code.
    // In reality:
    // 1. Checks Schema Hash (Immune System)
    // 2. Checks local VCR Cache (Mirror Neurons)
    // 3. Discovers Dad's Cell (Golgi Routing)
    // 4. Load Balances to the least busy instance (Mitosis)
    // 5. Serializes via Zero-Copy rkyv
    // 6. Returns result.
    let joke = DadJokeReq { topic: "Rust".to_string() }.send().await?;
    
    // Store it in another cell
    MemStoreReq::Set("favorite_joke", joke.pun).send().await?;
    
    Ok(())
}
```

This architecture transforms Rust from a "System Language" into a **"Distributed Biological Fabric."** You write single-threaded, simple logic, and the Cell Runtime handles the complexity of the network, state, scaling, and recovery.