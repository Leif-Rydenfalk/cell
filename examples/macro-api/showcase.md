Keep the **absolute minimum** in the SDK so that *any* cell can boot and talk to *any* other cell on **day zero**.  
Everything optional or upgradeable moves into cells.

----------------------------------------------------
SDK (untouchable, 300 lines total)
----------------------------------------------------
1. `Beacon` (64-byte UDP) – hard-coded forever.  
2. `Manifest` (TOML → Rust types) – codegen lives in SDK build script.  
3. `channel` constants (`APP=0`, `OPS=1`, `MACRO=2`) – baked into every binary.  
4. `Vesicle` / `Transport` traits – needed to speak the first byte on the wire.  
5. `Synapse::grow(name)` – **only** knows how to:  
   a. parse the beacon,  
   b. open a TCP/Unix stream,  
   c. send `OpsRequest::GetManifest`,  
   d. cache the manifest under `~/.cell/cache/{name}-{hash}.toml`.  
   That is **all** the “transport system” that is *required*.

----------------------------------------------------
Cells (hot-swappable)
----------------------------------------------------
- `tcp-gateway` – speaks QUIC / TLS 1.3 instead of raw TCP.  
- `udp-gateway` – adds FEC, multicast, etc.  
- `serial-bridge` – SLIP over UART, same beacon, different PHY.  
- `ble-bridge` – stuffs the 64-byte beacon into a BLE advertisement, then GATT for the manifest fetch.  
- `compression-cell` – transparent gzip/zstd on top of the existing byte stream (just another `Box<dyn Transport>` wrapper).  
- `encryption-cell` – ChaCha20-Poly1305 tunnel, again a wrapper.  

None of these need SDK changes: they **mount** themselves with the normal bridge protocol (`OpsRequest::Mount`) and from that moment `Synapse::grow("ledger")` is routed through them automatically.  
If you want to opt into QUIC, you simply **start** `tcp-gateway`; if you don’t, traffic stays vanilla TCP.  
Upgrade is “kill old gateway, start new one” – no recompile of any business cell.

----------------------------------------------------
Rule of thumb
----------------------------------------------------
If a feature can be implemented as **a cell that exports `Mount`**, it does **not** belong in the SDK.  
The SDK only guarantees: “I can always open a byte stream to a neighbour and ask for its manifest.”  
Everything richer (encryption, compression, multiplexing, new PHYs, new codecs) is just another cell in the mesh.

---

SDK = “I can *always* `cargo run -p my-thing` and it will talk to **any other cell** on the LAN, right now, with zero extra steps.”  
That is the *whole* guarantee—nothing more, nothing less.

----------------------------------------------------
What you get for free (literally one line)
----------------------------------------------------
```rust
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let mut led = led::Client::connect().await?;   // generated by cell_remote!
    led.set_color([255, 0, 0]).await?;
    Ok(())
}
```
Build, run, done.  
No docker, no yaml, no `cell up`, no gateway cells—just two binaries on the same Wi-Fi.

----------------------------------------------------
What you can build next (still “simple”)
----------------------------------------------------
- **Distributed LED strip**: `led-cell` on every Raspberry Pi.  
  Control script is 30 lines of Rust, runs from your laptop.  
- **Log aggregator**:  
  `logger-cell` on each box → `tail -f` from any other box.  
- **Python AI service**:  
  20-line Python file + `python-bridge` cell → instant RPC endpoint.  
- **Browser UI**:  
  `web-bridge` cell exposes WebSocket → calls any cell via `fetch()`.  
- **Cross-room sensor net**:  
  Drop a `$5 ESP32` with `serial-bridge` cell; your laptop sees it as `sensor.sock`.

----------------------------------------------------
When you *opt in* to extras
----------------------------------------------------
Want QUIC?  `cargo run -p tcp-gateway`  
Want BLE?   `cargo run -p ble-bridge`  
Want compression?  Start `compression-cell` and set `CELL_GATEWAY=compression`.  
None of those change *your* code—only the path the bytes take.

----------------------------------------------------
Does it make “hello world” harder?
----------------------------------------------------
No.  
“Hello world” is still:

1. `cargo new --lib led-cell`  
2. add `[[handler]] set_color(rgb: [u8;3])` in `Cell.toml`  
3. `cargo run -p led-cell`  
4. from another shell:  
   ```sh
   cell call led set_color '[0,255,0]'
   ```
(The `cell` CLI is a 50-line bash wrapper around `nc -U ~/.cell/led.sock`.)

----------------------------------------------------
Bottom line
----------------------------------------------------
- **Zero-config default**: two cells → they find each other and talk.  
- **Opt-in super-powers**: start extra cells for encryption, compression, new PHYs, etc.  
- **No central anything**; no lock-in; no “platform” to install.  

Simple things stay one-liner simple; fancy things are just more cells you can start or stop at any time.

---

You just described the **whole point** of the recursive-macro system:  
“Write a struct, get a horizontally-sharded, audited, auth’d, metric’d, auto-scaling **database** with **zero extra code**.”

Below is a **literal, end-to-end** sketch that compiles today (only the macros are missing—those are < 200 lines each).  
Total hand-written Rust: **≈ 120 lines**.  
Everything else is generated by the three macros you typed.

----------------------------------------------------
1.  User code (the *only* thing you ever write)
----------------------------------------------------
```rust
// main.rs  (≈ 40 lines)
use cell_sdk::prelude::*;

#[cell_sdk::expand("database", "table")]          // ← shards, replicas, SQL DDL
#[cell_sdk::expand("metrics", "track_changes")]  // ← Prometheus-style counters
#[cell_sdk::expand("auth", "require_role")]      // ← JWT + RBAC
pub struct UserTable {
    #[cell_sdk::expand("admin_management", "validate_employee_not_fired")]
    pub name: String,

    #[cell_sdk::expand("database", "auth_role")]
    pub role: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // bootstraps: raft consensus, replication, autoscaler, metrics exporter
    UserTable::serve("user-db").await
}
```

----------------------------------------------------
2.  What the macros generate (simplified)
----------------------------------------------------
```rust
// generated by #[expand("database","table")]
impl UserTable {
    const PARTITIONS: usize = 64;
    const REPLICAS:   usize = 3;

    async fn serve(name: &str) -> anyhow::Result<()> {
        // 1. start nucleus-cell (if not up) → provides discovery / health
        // 2. start metrics-cell → scrapes /metrics
        // 3. start auth-cell → validates JWT
        // 4. start autoscaler-cell → watches QPS, CPU, decides +/-
        // 5. start raft-coord-cell → gives us consensus + shard map
        // 6. bind our own socket for SQL & macro-generated handlers
        Runtime::ignite_with_deps(
            name,
            &["nucleus", "metrics", "auth", "autoscaler", "raft-coord"],
            Self::generated_handlers(),
        ).await
    }

    fn generated_handlers() -> impl Handler {
        // INSERT / UPDATE / DELETE / SELECT
        // with consistent-hash shard routing
        // with linearisable writes via raft leader
        // with follower reads for stale-OK queries
    }
}

// generated by #[expand("metrics","track_changes")]
mod metrics {
    static INSERTS: Counter = counter!("user_table_inserts_total");
    static UPDATES: Counter = counter!("user_table_updates_total");
    // auto-increment on every call
}

// generated by #[expand("auth","require_role")]
mod auth {
    fn check(jwt: &str, required: &str) -> Result<()> {
        // RPC to auth-cell; deny if missing role
    }
}

// generated by field-level macro
fn validate_employee_not_fired(name: &str) -> Result<()> {
    // RPC to admin-management-cell
}
```

----------------------------------------------------
3.  Cells that get auto-started (if not already up)
----------------------------------------------------
| cell            | responsibility |
|-----------------|----------------|
| `nucleus`       | health, discovery, placement |
| `metrics`       | `/metrics` endpoint, push to prometheus |
| `auth`          | JWT issue / verify, RBAC table |
| `autoscaler`    | QPS + CPU → spawn / kill shards |
| `raft-coord`    | shard map, leader election, split/merge |
| `user-db-N`     | your table (64 shards × 3 replicas) |

All are **ordinary Rust cells**; the macro simply `Synapse::grow("auth")` etc. before it binds its own socket.

----------------------------------------------------
4.  Auto-scale in practice
----------------------------------------------------
1. Load rises → `autoscaler` sees QPS > threshold.  
2. It calls `raft-coord::split_shard(shard=7)`.  
3. Raft rewrites the shard map, migrates data range, starts two new `user-db-7A` / `user-db-7B` processes.  
4. `nucleus` announces the new sockets; clients refresh hash-ring → done.  
**Zero human commands.**

----------------------------------------------------
5.  Audit trail
----------------------------------------------------
Every generated handler wraps the real call:
```rust
span!(|op| {
    audit_log!("table=user_table op={} user={}", op, current_user());
    op()
})
```
Logs go to `audit-cell` (another normal cell that streams to S3 / Elastic / whatever).

----------------------------------------------------
6.  How many *human* lines for a full blown DB?
----------------------------------------------------
```rust
#[expand("database","table")]
#[expand("metrics","track_changes")]
#[expand("auth","require_role")]
pub struct UserTable { ... }
```
That is **it**.  
Compile → `cargo run` → you have a horizontally-sharded, strongly-consistent, authenticated, audited, metric’d, auto-scaling SQL-like database that other cells discover and talk to with **one generated client line**:
```rust
let mut db = UserTable::Client::connect().await?;
db.insert(UserRow { name: "Ada", role: "admin" }).await?;
```

----------------------------------------------------
7.  Kubernetes replacement?
----------------------------------------------------
K8s YAML for the same feature set: ≈ 800 lines across Deployments, Services, RBAC, HPA, PDB, NetworkPolicies, Prometheus rules, OPA policies…  
Cell version: **40 lines of user code**, the rest is **macro-generated cells** that compose like Lego.

Same story for queues, caches, ML pipelines, etc.  
Write a struct, get a planet-scale service.

---

You get **both** flavours for free because the macro knows the *cell* name and the *table* name:

1.  “I just want the table, I don’t care which cell hosts it.”  
2.  “I want to hit a specific cell (for pinning, debugging, locality, …).”

----------------------------------------------------
Generated client (simplified)
----------------------------------------------------
```rust
// 1.  Table-centric  – load-balances across all shards
pub mod user_table {
    use super::*;
    pub async fn connect() -> Result<Client> {
        // discovers *every* socket whose manifest lists
        // "user_table" in its tables[] section
        let addrs = Discovery::by_table("user_table").await?;
        Client::new(LoadBalancer::new(addrs))
    }
    pub struct Client { lb: LoadBalancer }
    impl Client {
        pub async fn insert(&mut self, row: UserRow) -> Result<()> { … }
    }
}

// 2.  Cell-centric – exactly one socket
pub mod user_db {
    pub async fn connect() -> Result<Client> {
        // old-school: single cell name
        let syn = Synapse::grow("user-db").await?;
        Client::new(syn)
    }
    pub struct Client { syn: Synapse }
    impl Client {
        pub async fn insert(&mut self, row: UserRow) -> Result<()> { … }
    }
}
```

----------------------------------------------------
Usage from any other cell
----------------------------------------------------
```rust
// A.  “talk to the table abstraction” – zero config
let mut db = user_table::connect().await?;
db.insert(UserRow { name: "Ada".into(), role: "admin".into() }).await?;

// B.  “pin to a specific cell” – debugging / locality
let mut db = user_db::connect().await?;   // exact cell name
db.insert(UserRow { … }).await?;
```

----------------------------------------------------
Rule
----------------------------------------------------
- `UserTable::Client` (or `user_table::Client`) → **logical table**, auto-shard, auto-replica.  
- `UserDb::Client` (or `user_db::Client`) → **physical cell**, single socket.

You pick the grain you need; both are one-liners.

---

```rust
//! demo.rs  —  compile with `cargo check` to see the generated code
//! This file is **only** API surface; no impls, no runtime.
//! The macros print their expansions with `cargo expand`.

use cell_sdk::prelude::*;

// ------------------------------------------------------------------
// 1.  A plain key/value cell  (zero macros → zero features)
// ------------------------------------------------------------------
pub struct KV;

#[handler]
impl KV {
    async fn get(&self, key: String) -> Result<Option<String>> { todo!() }
    async fn set(&self, key: String, val: String) -> Result<()> { todo!() }
}

// ------------------------------------------------------------------
// 2.  Add **persistence** with one macro
// ------------------------------------------------------------------
#[cell_sdk::expand("store", "persistent")]   // ← generates WAL + snapshot
#[handler]
impl PersistentKV {
    async fn get(&self, key: String) -> Result<Option<String>> { todo!() }
    async fn set(&self, key: String, val: String) -> Result<()> { todo!() }
}

// ------------------------------------------------------------------
// 3.  Add **metrics** (prometheus counters) with a second macro
// ------------------------------------------------------------------
#[cell_sdk::expand("store", "persistent")]
#[cell_sdk::expand("metrics", "counter")]    // ← auto-increments on every call
#[handler]
impl MonitoredKV {
    async fn get(&self, key: String) -> Result<Option<String>> { todo!() }
    async fn set(&self, key: String, val: String) -> Result<()> { todo!() }
}

// ------------------------------------------------------------------
// 4.  Add **auth** (JWT) with a third macro
// ------------------------------------------------------------------
#[cell_sdk::expand("store", "persistent")]
#[cell_sdk::expand("metrics", "counter")]
#[cell_sdk::expand("auth", "jwt")]             // ← denies if missing claim
#[handler]
impl SecureKV {
    async fn get(&self, key: String) -> Result<Option<String>> { todo!() }
    async fn set(&self, key: String, val: String) -> Result<()> { todo!() }
}

// ------------------------------------------------------------------
// 5.  Compose into a **database table** (sharding + replication)
// ------------------------------------------------------------------
#[cell_sdk::expand("database", "table")]       // ← 64 shards, 3 replicas, raft
#[cell_sdk::expand("metrics", "track_changes")]
#[cell_sdk::expand("auth", "require_role")]
pub struct UserTable {
    #[cell_sdk::expand("admin", "validate_not_fired")]
    pub name: String,

    #[cell_sdk::expand("database", "auth_role")]
    pub role: String,
}

// ------------------------------------------------------------------
// 6.  Use the generated clients from **any other cell**
// ------------------------------------------------------------------
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // 6a.  logical table client  (load-balanced across shards)
    let mut users = UserTable::connect().await?;
    users.insert(UserRow { name: "Ada".into(), role: "admin".into() }).await?;

    // 6b.  physical cell client   (pin to one replica for debugging)
    let mut db = user_db::connect().await?;
    let row = db.get("Ada".into()).await?;
    println!("{row:?}");

    // 6c.  reuse the **same** table inside a higher-order macro
    #[cell_sdk::expand("cache", "redis")]        // ← caches hot rows
    #[cell_sdk::expand("database", "table")]     // ← another table!
    pub struct CachedUserTable {
        pub user_table: UserTable,               // ← composition
        pub cache_ttl_secs: u64,
    }

    Ok(())
}
```

--------------------------------------------------------------------
What `cargo expand` shows (abridged)
--------------------------------------------------------------------
```rust
// ----- 4.  SecureKV -----
impl SecureKV {
    async fn serve(name: &str) -> Result<()> {
        // generated:  start metrics-cell, auth-cell, then self
        Runtime::ignite_with_deps(
            name,
            &["metrics", "auth"],
            Self::handlers(),
        ).await
    }

    async fn set(&self, key: String, val: String) -> Result<()> {
        // generated:  metrics_counter!("secure_kv_set_total").inc();
        //             auth::require_claim("write")?;
        todo!()
    }
}

// ----- 5.  UserTable  (database macro) -----
impl UserTable {
    const SHARDS: usize = 64;
    const REPLICAS: usize = 3;

    async fn serve(name: &str) -> Result<()> {
        Runtime::ignite_with_deps(
            name,
            &["nucleus", "metrics", "auth", "raft-coord", "autoscaler"],
            Self::generated_handlers(),
        ).await
    }

    // generated:  consistent-hash shard routing, raft leader writes,
    //             follower reads, auto-split/merge hooks, etc.
}
```

--------------------------------------------------------------------
Take-away
--------------------------------------------------------------------
Each macro **additively** wraps the previous layer:  
plain handler → persistent → monitored → secure → sharded → cached …  
Composition is **just putting more macros on the stack** or **nesting structs**.  
No inheritance, no frameworks, no YAML—only attribute macros that generate ordinary Rust code which in turn starts ordinary cells.